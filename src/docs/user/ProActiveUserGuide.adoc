= User guide
include::../common.adoc[]

== Overview
*ProActive Parallel Suite* is an open source software middleware which facilitates distributed and parallel computations on clusters of computation resources which can vary from commodity hardware such as laptops, desktops to high-end servers. It incorporates numerous features such as dynamical resource acquisition and management, distributed workflows, cloudbursting on public/private clouds etc,, to cater a wide spectrum of organizational requirements.

In a nutshell, ProActive Parallel Suite framework consists of two main components, a *Scheduler* and a *Resource Manager*. The user specifies the computation that he/she desires in terms of series computation steps along with their execution and data dependencies. The scheduler executes this computation on a cluster of computation resources, each step on the best-fit resource and in parallel wherever its possible. 

== Get started

The first thing you need is a Scheduler running either:

- Locally on your machine, see the link:ProActiveAdminGuide.html#_getting_started[Administration guide] to help you with a local installation
- On http://try.activeeon.com[try.activeeon.com], our free demo platform
- On an existing installation

Then to use the Scheduler, web interfaces are available to:

- Create workflows
- Submit workflows, monitor their execution and retrieve the tasks results
- Add resources and monitor them

We also provide REST and command line interfaces for advanced users.

== Create and run your computation

=== Jobs, workflows and tasks

In order to use Scheduler for executing various computations, one needs to write the execution definition also known as the Job definition. A job definition is an XML file that adheres to XML Schema for ProActive Jobs. It specifies a number of XML tags for specifying execution steps, their sequence and dependencies. Each execution step corresponds to a task which is the smallest unit of execution that can be performed on a computation resources. There are several types of tasks which caters different usecases. For instance, a script task can be used to execute an inline script definition or a script file as an execution step whereas a native task can be used to execute a native executable file. It also possible to package an job definition along with its dependencies (libraries, executables etc) into a self-contained archive. 

ProActive Parallel Suite currently supports three main types of tasks: 

- Native Task,, an executable with eventual parameters to be executed
- Script Task, a script writen in Groovy, Ruby, Python and other languages supported by the JSR-223
- Java Task,, a task written in Java extending the Scheduler API

One can use **ProActive Workflow Studio**  to create and submit jobs graphically . They  can simply drag-and-drop various task constructs and draw their dependencies to form complex jobs. It also provides various flow control widgets such as conditional branch, loop., replicate etc to construct complex workflows. 

TODO image workflow

In this tasks graph, we see that task 4 is preceded by task 1, that
means scheduler waits the end of task 1 execution before launching task
4. In a more concrete way, task 1 could be the calculation of a part of
the problem to solve, and task 4 takes result provided by task 1 and
compute another step of the calculation. We introduce here the concept
of **result passing** between tasks, explained later. This relation is
called a dependence, and we say that task 4 **depends** on task 1.

We see that task 1, 2 and 3 are not linked, so these three tasks can be
executed in **parallel**, because there are independent from each other.

Definition of the workflow graph is made at job definition, before
scheduling, and cannot be modified during the job execution

A *finished job* contains the results and logs of each task. Upon failure,
a task can be restarted automatically or cancelled.

=== A simple example

The http://try.activeeon.com/tutorials/quickstart/quickstart.html[quickstart tutorial] on http://try.activeeon.com[try.activeeon.com]
shows you how to build a simple workflow using script tasks.

=== More examples

==== Native application

Using native tasks you can easily reuse existing applications and embed them in a workflow. For instance let's imagine
Concrete example

Native application by nature can be tied to a given operating system so
if you have different nodes at your disposal, you might need to select a suitable node to run your native task.
This can be achieved using selection script.

==== Scripts (more languages example ruby, python)

Scripts are for debug/small tasks

==== MPI application

mpirun example

=== Run a workflow

submission

==== Job/Task states
==== Retrieve results

== Data Management

Passing data between tasks
parameters / results
variable / properties (example: native task with env variables, using pre script XOR forkenv)
Input/Output data (introduce NFS, dataspaces, global and user spaces)
A job that reads data from files and outputs in a file

== Workflow concepts

Control flow
If
Replicate
Example: Solving a Parameter sweeping/Embarrassingly parallel problem (Link to tutorial)
Loop

== Job/Task customization

Workflow scripts
Selection
Pre/Post/Clean
Control execution
Run computation on a particular node (Selection?)
Run computation with your system account
Reserve more than one node for a task (parallel environment)
Handling failures (retry on error, max number of exec, cancel on error, ...)
Planification

== Other

== References

[appendix]
=== Job and task specification

[appendix]
=== CLI tools
